exit
answer = JSON.parse(response.body)
answer = JSON.parse response.body
answer = response.body
answer = JSON.parse response.body
response
exit
answer = JSON.parse(response.body)
n
exit
forecast.forecast_by_time(time)
exit
forecast.forecast_by_time(time)
exit
forecast.forecast_by_time(time)
exit
forecast.forecast_by_time(time)
forecast.methods.include?(:forecast_by_time)
exit
forecast.forecast_by_time(time)
forecast.methods.include?(:forecast_by_time)
exit
forecast
forecast.methods.include?(:forecast_by_time)
forecast.forecast_by_time(time)
forecast = forecast(time)
exit
forecast = described_class.new
forecast.methods.include?(:forecast_by_time)
forecast.forecast_by_time(time)
forecast = described_class.new
exit
forecast.forecast_by_time(time)
forecast = described_class.new
forecast = described_class.new.forecast_by_time(time)
forecast = described_class.forecast_by_time(time)
forecast = forecast_by_time(time)
exit
forecast = forecast_by_time(time)
forecast = forecast_by_time
exit
forecast = forecast_by_time
forecast = forecast_by_time(time)
exit
Exchange.methods.include?(:forecast_by_time)
Exchange.methods.include?(forecast_by_time)
Exchange.methods
Exchange.forecast_by_time
Exchange.forecast_by_time(time)
Exchange
forecast = forecast_by_time(time)
exit
forecast = forecast_by_time(time)
forecast = forecast_by_time time
exit
exir
exit
forecast['record']
forecast = test_client.forecast_by_time(time)
forecast_by_time
forecast_by_time['time']
time
forecast = test_client.forecast_by_time time
byebug
expect(forecast['time']).to eq(5)
forecast = test_client.forecast_by_time time
test_client
exit
c.send(:hours)
c.methods.include?(:hours)
c.methods.include?(hours)
c.methods
c.nomethod
exit
c.hours
c.hours.exists?
expect(Fugit.parse('every 3 hours in Europe/Moscow').original).to eq(cron)
expect(c.rough_frequency).to eq(10800)
expect(c.hours).to eq([0, 3, 6, 9, 12, 15, 18, 21])
c.hours
exit
cron = schedule['forecast_job']['cron']
schedule['forecast_job']
schedule
exit
c = Fugit::Cron.parse(cron)
cron
c
n
exit
cron
exit
учше
WeatherForecast.all
exit
WeatherForecast.all
WeatherForecast.exists?
exit
WeatherForecast.exists?
WeatherForecast.count
WeatherForecast.all
exit
WeatherForecast.all
forecast = WeatherForecast.find_by(date: time)
exit
WeatherForecast.all
exit
WeatherForecast.all
WeatherForecast.count.zero?
exit
job
ForecastJob.jobs
exit
job
described_class
described_class.new.perform_now
exit
described_class.new.perform_now
described_class.new.perform
exit
ForecastJob.jobs
job
exit
job
exit
job
job.jobs
ForecastJob.jobs
exit
 Sidekiq::Testing.fake! { get '/exports' }
 Sidekiq::Testing.fake! { post '/exports' }
ForecastJob.new.perform_now
ForecastJob.new.perform
exit
v["name"]
schedule.size
v["class"]
v
exit
klass.constantize 
k
klass.underscore
klass
v
schedule
klass.underscore
k
klass
exit
schedule
exit
sidekiq_file = Rails.root.join("config", "sidekiq.yml")
schedule
exit
WeatherForecast.count
exit
WeatherForecast.count
exit
expect(option_mock).to have_received(:options)
option_mock.options
expect(option_mock).to have_received(:options)
exit
expect(option_mock).to have_received(:options)
option_mock.options
expect(option_mock).should_receive(:options)
expect(option_mock).expect(:options)
expect(option_mock).should_receive(:options)
option_mock.send
option_mock
exit
option_mock.send(:options)
option_mock.options
exit
option_mock.options
option_mock
exit
it { expect(option_mock.options).to be_a(Hash) }
option_mock.options
option_mock
exit
stub.send(:options)
stub
exit
city_key
exit
create_data.sample.keys
create_data.sample.keys.size
create_data.sample.class
create_data.sample
attributes_for(:weather_forecast) 
create_data.blank?
create_data.blank&
parse_epoch(create_data[0]['EpochTime']).class
parse_epoch(create_data[0]['EpochTime'])
create_data[0]['EpochTime'].class
expect(WeatherForecast.count).to eq(24)
create_data[0]['EpochTime']
create_data[0]data['EpochTime']
create_data[0]['Temperature']['Metric']['Value']
create_data.status
create_data[0]['Temperature']['Metric']['Value']
create_data[0]
create_data.size[0]
create_data.size
create.data.size
WeatherForecast.count
WeatherForecast.size
create_data.class
create_data
exit
VCR.use_cassette('location_key') { described_class.new.send(:location_key) }
VCR.use_cassette('update_data') { described_class.new.update_data }
VCR.use_cassette('create_data') { described_class.new.create_data }
exit
VCR.use_cassette('create_data') { forecast.create_data }
exit
JSON.parse(last_response.body)
JSON.parse(last_response.body)[0]
JSON.parse(last_response.body)
expect(JSON.parse(last_response.body))
expect(JSON.parse(last_response.body)
expect(JSON.parse(last_response.body)[0])
expect(last_response.status).to eq(200)
exit
get "/weather/by_time?time=4"
get "/weather/by_time?time=#{4}"
time_epoch(time_nearest[:nearest].values)
last_response.status
exit
WeatherForecast.all
WeatherForecast.count
exit
WeatherForecast.order('temperature DESC').first
WeatherForecast.order('temperature DESC')
WeatherForecast.all
JSON.parse(last_response.body)
last_response.status
get '/api/v1/weather/historical/max'
last_response.status
num
exit
JSON.parse(last_response.body)['record'].size
JSON.parse(last_response.body)['record']
JSON.parse(last_response.body)
JSON.parse(last_response.body).size
last_response.status
last_response.body
exit
num.send(:date)
num.class
num = WeatherForecast.order('date DESC').first
num.send(:date)
num.send(date)
num.constantize.find_by(date:)
num.constantize
num.inject
