exit
JSON.parse(last_response.body)
JSON.parse(last_response.body)[0]
JSON.parse(last_response.body)
expect(JSON.parse(last_response.body))
expect(JSON.parse(last_response.body)
expect(JSON.parse(last_response.body)[0])
expect(last_response.status).to eq(200)
exit
get "/weather/by_time?time=4"
get "/weather/by_time?time=#{4}"
time_epoch(time_nearest[:nearest].values)
last_response.status
exit
WeatherForecast.all
WeatherForecast.count
exit
WeatherForecast.order('temperature DESC').first
WeatherForecast.order('temperature DESC')
WeatherForecast.all
JSON.parse(last_response.body)
last_response.status
get '/api/v1/weather/historical/max'
last_response.status
num
exit
JSON.parse(last_response.body)['record'].size
JSON.parse(last_response.body)['record']
JSON.parse(last_response.body)
JSON.parse(last_response.body).size
last_response.status
last_response.body
exit
num.send(:date)
num.class
num = WeatherForecast.order('date DESC').first
num.send(:date)
num.send(date)
num.constantize.find_by(date:)
num.constantize
num.inject
num.slice('date')
num.slice(date)
num.slice(:date)
num.slice
num.sole
num.first
num.extending_values
num.annotate_values
num.to_sql
num.attributes
num['date']
num[:date]
num
num.to_ary.class
num.to_ary
num.to_value
num.to_values
num.to_params
num.to_param
num.values
num
num.touch_all
num.methods
num.date
num.class
num = WeatherForecast.order('date DESC').limit(1)
num.class
num = WeatherForecast.order('date DESC').take(1)
num.class
num.take(0)
num.take(1)
num.take
num.second
num.methods
num.methoda
num.instance_variable_set(:"@#{date}", 4)
num
num.instance_variable_set(:@date, 4)
num.instance_variable_set(:@date, num).date
num.instance_variable_set(:@date, num).size
num.instance_variable_set(:@date, num).class
num.instance_variable_set(:@date, num)
num.instance_variable_set(:@date, date)
num.instance_variable_set(:@date)
num.instance_variable_get(:@date)
num.instance_variable_get(@date)
num.instance_variable_get
num.instance_variable_get(:"@#{date}")
num.instance_variable_get("@#{date}")
num.instance_variable_get(:"@#{date})
num.instance_variable_get("@#{num}")
num = WeatherForecast.order('date DESC').take(1)
num
num.excluding(:data)
num.excluding(data)
num.including
num.instance_variable_get("@#{num}")
num.instance_variable_get("@#{date}")
num.instance_variable_get(:"@#{date}")
num.instance_variable_get(:"@#{date})
num.instance_variable_get(:date)
num.instance_variable_get(date)
num.instance_variable_get
num.instance_variable_names
instance_variable_set(:"@#{num}", num)
instance_variable_set(:"@#{date}", num)
instance_variable_set(:"@#{date}")
num.instance_variable_set(:"@#{date}")
num.instance_variable_set(:"@#{date}", date)
num.instance_variable_set(:"@#{method}", value)
num.instance_variable_set
num.compact
num.compac
num.compact_blank
num.drop
num.fourth
num.tap
JSON.parse(num.to_json)
JSON(parse(num.to_json))
num.pop
num.union.size
num.union.class
num.union
num.at
num.to_fs
num.to_sentence
num.to_query
num.to_param
num.to_json
num.last
num.third
num.send(:date)
num.methods
num.size
num
exit
num.attributesexit
num.attributes
num
num['date']
num[:date]
num.date
num.class
num
exit
time
exit
get '/api/v1/weather/current'
WeatherForecast.order('date DESC').first
WeatherForecast.order('date DESC')
exit
WeatherForecast.where(date: r['EpochTime']).first_or_create(temperature: r.dig('Temperature', 'Metric', 'Value'))
r = answer[0]
answer[0]
answer.count
answer = respond_with(response)
respond_with(response)
response ||= Faraday.get("#{BASE_URL}/currentconditions/v1/#{location_key}/historical/24?", options.slice(:apikey))
response
options.slice(:apikey)
location_key
exit
response
exit
response.status
response.success?
exit
response.success?
response.successful?
response.status
response.body
JSON.parse(response.body)['Code']
JSON.parse(response.body)['Code'] == "404"
exit
JSON.parse(response.body)['Code'] == "404"
JSON.parse(response.body)['Code']
JSON.parse(response.body)
response.body
response
exit
connection
response ||= connection.get(PATH, options)
